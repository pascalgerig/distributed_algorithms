\documentclass{article}
\usepackage{geometry}
\usepackage{paralist}
\usepackage[T1]{fontenc}
\usepackage{reledmac}
\usepackage{changepage}
\usepackage{amsmath}
\usepackage{scalerel,amssymb}

\usepackage{pgfplots}
\usepackage{tikz}
\usetikzlibrary{positioning}
\usetikzlibrary{shapes.geometric, arrows}
\tikzstyle{arrow} = [thick,->,>=stealth]

\usepackage{fancyhdr}
\fancyhead[L]{
	\begin{tabular}{l}
		\LARGE \textbf{\textsc{Distributed Algorithms}} \\
		\Large Exercise 09
	\end{tabular}
}
\fancyhead[R]{
	\begin{tabular}{r}
		16-104-721 \\
		Pascal \textsc{Gerig}
	\end{tabular}
}
\renewcommand{\headrulewidth}{0.4pt}
\fancyfoot[C]{\thepage}
\renewcommand{\footrulewidth}{0.4pt}

\usepackage{hyperref}

\begin{document}
	\pagestyle{fancy}
	
    \section*{9.1 Flooding Consensus}
    \begin{enumerate}[a)]
        \item With two processes $p$ and $q$, we clearely have $N$ = 2, thus the regular algorithm would iterate twice.
        Lets now assume, that it is possible to reduce the number of rounds by one on one process (here on $p$).
        If $p$ proposes $v$ and $q$ proposes $w$, then it might be, that $p$ has broadcasted $v$ to itself, but not yet to $q$ and $q$ has broadcasted $w$ to both processes.
        In this scenario, if only one round is executed, $p$ is able to decide on a value, lets assume it decides on $v$.
        Right after the decision, $p$ might crash - The failure detector of $q$ therefore detects $p$ as crashed.
        $q$ has not received the proposed value of $p$, but has beb-delivered its own proposal $w$. Therefor, it completes round one, and starts round two, where $q$ just deliveres its proposal to itself (and not to $p$ since it has crashed).
        After round two, $q$ has no other choice than deciding $w$ which clearly violates the \textit{uniform agreement} property.
        \item Lets consider a scenario with two processes $p$ and $q$ where each one has proposed a value. Since $N$ = 2, there are two rounds in the algorithm.
        Lets assume that the failure detector of both processes suspects the other process during the first round.
        Both processes are able to start round two having no knowledge about the proposed value of the other process.
        In the second round, both failure detectors eventually become perfect and indicate that no process has failed yet.
        At this point the scenario equals a scenario, where the Algorithm is run with $N - 1$ rounds, thus the \textit{uniform agreement} property can be violated in the exact same way, where a process decides and then crashes.
        This shows, that an eventually perfect failure detector is not enough for this algorithm to execute correctly.
    \end{enumerate}

    \section*{9.2 Leader-Driven Consensus}
    \begin{enumerate}[a)]
        \item The algorithm needs more than $N/2$ states when reading from other processes, and more than $N/2$ confirmations when writing to other processes.
        This ensures, that at least one process whitnesses the writes. If a majority of processes is faulty and do not respond, then the conditions $\#(states) > N/2$ and $accepted > N/2$ might never be satisfied.
        \item As the two conditions in a) might never be met, a process might never decide. This violates the \textit{termination} property.
        \item TODO
    \end{enumerate}

    \section*{9.3 Leader-Driven Consensus, optimized}
    
    
\end{document}s